Terminology:
Leaf flex container: has no 'container' flex items.
 Layout > no recursion, produces lw, lh
Complex flex container: contains both simple flex items and container flex items.




/**
 * Peforms flexbox layout on this flex container.
 */
layout():
- If first layout of frame, set lw/lh to rw/rh, and bw/lh to rw/rh.
- const horizontal = flexDirection == 'row' || flexDirection === 'row-reverse'
- const reverse = flexDirection == 'row-reverse' || flexDirection == 'column-reverse'
- const mainAxisSize = horizontal ? lw : lh
- const crossAxisSize = horizontal ? lh : lw
- const wrap = ((horizontal ? rw : rh)) > 0)
- const items = this.children;
- items.forEach(item):
  if (child.isFlexContainer()) {
  	// Make sure that lw, lh are set correctly.
    child.layout();
  }
- this.distributeItemsOnMainAxis(items, mainAxisSize)

1. Perform one layout operation on all children:
 - if child is flex container: child.layout() (recurses until leaf flex container)
 - if child is simple flex item: child.lw = child.rw; child.lh = child.rh;


- Distribute all lines, based on current bw, bh values only (for simple flex items, rw, rh can be used).
- This creates a new lx,lw or ly,lh for all items (dependent on direction)
- In case of align-content: stretch, determine total line height, and calculate 'extra' pixels needed per line.
- alignLines(items): Line by line, apply alignCrossAxisForLayoutLine and supply 'extra' as well.
- items.forEach(item):
 - if (item.isFlexContainer):
     if (item.flex.alignContent === 'stretch') {
     	// Changing the height will most likely cause line cross axis sizes to change.
     	let redistribute = item.flex.alignLines()

     }
 - check for this.isPerpFlexContainer(item), and if found:
  -


2. If nowrap:
 Place all items in one line.
 let redistribute = true;
 while(redistribute) {
   this.distributeItemsOnMainAxis(items, 0);

   // Cross axis stretching may cause main axis changes
   redistribute = this.alignCrossAxisForLayoutLine(items)
 }

 The cross axis sizes may be changed. This may cause a change on the child flex containers.
 items.forEach(item):
   if item.isFlexContainer():
     item.relayout()

3. Group first line, by identifying when it should break:
 - if nowrap, then this is simple: one line with all items aligned
 - if wrap, check all 'lw' values and continue until the line is 'full'


FlexItem:
- lw
- lh
- lineIndex : number (0, 1, 2, etc.)

FlexContainer:
- baseMainAxisSize ('own' calculated main axis size, without any stretching/growing/shrinking applied)

/**
 * Determines which items 'fit' on the main axis, and distribute them over it, setting their position and sizes on it.
 * @param {View[]} items
 * @return number
 *   The number of items (from the beginning of the items array) that fit on the line.
 */
FlexContainer.distributeItemsOnMainAxis():
- const items = this.children;
- if (!mainAxisSize) {
	// Simple: just a single line!.
  }

  Are layouts immediately done?
  resizeMainAxis(size)
  I think so: if not perp, the lw/lh main axis size must simply be adhered to.
  If item nowrap is enabled (fit), then we can set the main axis size without recalculating (positions will not change, cross size will not change).
  If wrap is enabled, and main axis size has changed, it must be re-layout.


/**
 * Applies growing/shrinking to items on the specified line.
 * This may force the main axis of the items to be set.
 */
FlexContainer.resizeLine(items):
- lineSize = this.getMainAxisSize(this)
- accumulate items width: totalSize
- const remaining = lineSize - totalSize // Notice that negative is possible.
- if (remaining > 0) {
	// Grow items by set items ratio.
	- Accumulate total grow value of all items combined: totalGrow
	- sizePerGrowUnit = totalGrow ? remaining / totalGrow : 0
	items.forEach(item):
	  resizeMainAxis(FlexContainer.getBaseMainAxisSize(item) + sizePerGrowUnit * item.grow);
  } else if (remaining < 0) {
	- Do the same, but then for shrink.
  } else {
	items.forEach(item):
	  resizeMainAxis(FlexContainer.getBaseMainAxisSize(item));
  }
Todo: baseSize, grow, shrink, etc.

/**
 * Called when the main axis of this flex container is resized by the parent flex container.
 * @param {number} size
 */
FlexContainer.resizeMainAxis(size):
- const prevSize = this.getMainAxisSize(this);
- if (prevSize === size) return;
- this.setMainAxisSize(this, size);
- if (!this.wrap()) return; // Positions will not change.
- this.distributeItemsOnMainAxis()



/**
 * Called when the cross axis of this flex container is resized by the parent flex container.
 * @param {number} size
 */
FlexContainer.resizeCrossAxis(size):
- const prevSize = this.getCrossAxisSize(this);
- if (prevSize === size) return;
- this.setCrossAxisSize(this, size);
- if (this.alignContent === "stretch") {
	let redistribute = this.alignLines(items)
	while (redistribute) {
		this.distributeItemsOnMainAxis()
		this.alignLines(items)
	}
  }

/**
 * Aligns all layout lines on the cross axis, one by one.
 * @return {boolean} redistribute
 *  Return true iff any of the (flex container) children's main axis size has changed due to cross-axis stretching.
 *  This requires the items to be re-distributed according to the new layout dimensions, possibly triggering layouts.
 */
FlexContainer.alignLines(items):
- split items into 2d lines array
- accumulate totalCrossAxisSize for all line using maxCrossAxisSize(line)
- if alignContent.stretch is set: calculate additionalPixelsPerLine, otherwise use 0.
- let base = 0;
- let redistribute = false;
- lines.forEach(line):
  redistribute = redistribute || alignCrossAxisForLayoutLine(lines, base, additionalPixelsPerLine)
  base += maxCrossAxisSize(line)
- return redistribute

/**
 * Applies cross-axis alignment for items on the same layout line.
 * @param {View[]} items
 * @param {number} base
 *  The base position for the line.
 * @param {number} extra
 *  Additional amount of pixels to add to maxCrossSize.
 *  Used to distribute remaining size when align-content:stretch is set.
 * @return {boolean} redistribute
 *  Return true iff any of the (flex container) children's main axis size has changed due to cross-axis stretching.
 */
FlexContainer.alignCrossAxisForLayoutLine(items, base, additionalPixels):
- if reverse, then items.reverse()
- find maxCrossSize: max cross axis size of all items
- let redistribute = false;
- items.forEach(item):
  const align = item.alignSelf || this.alignItems
  switch(align) {
  	case "flex-start":
  		this.setCrossAxisPos(item, base);
  	case "flex-end":
  		this.setCrossAxisPos(item, base + (maxCrossSize - this.getCrossAxisSize(item));
  	case "center":
  		this.setCrossAxisPos(item, base + ((maxCrossSize - this.getCrossAxisSize(item)) * 0.5));
  	case "stretch":
  		this.setCrossAxisPos(item, base);
  		if (getCrossAxisSize(item) !== maxCrossSize) {
  			const prevItemCrossAxisSize = this.getMainAxisSize(item);
	  		this.setCrossAxisSize(item, maxCrossSize);

	  		if (item.isFlexContainer() && this.isPerpFlexContainer(item)) {
	  			// Increasing the main axis size of the child, may cause it's cross axis size to change because items are re-distributed.
	  			// And cross axis size may be 'fit' to contents (stay equal or decrease).
	  			// If this is the case, the 'main' axis size on this layout line is changed, possibly changing the distribution and main axis positions/sizes of ALL items!
		  		item.relayout();

		  		const itemCrossAxisSize = this.getMainAxisSize(item);
		  		if (itemCrossAxisSize !== prevItemCrossAxisSize) {
		  			redistribute = true
		  		}
	  		}
  		}
  }
- return redistribute

/**
 * Returns the maximum size of the cross axis for the specified items.
 * @param {View[]} items
 * @return number
 */
FlexContainer.maxCrossAxisSize(items)

/**
 * Returns the currently set position of that flex item on the cross axis, relative to the scan line itself (not the flex container).
 */
FlexContainer.getCrossAxisPos(flexItem)

FlexContainer.setCrossAxisPos(flexItem, pos)

FlexContainer.getCrossAxisSize(flexItem)

FlexContainer.setCrossAxisSize(flexItem, size)













Relayout:
Set mainAxisSize = horizontal ? lw : lh
Set crossAxisSize = horizontal ? lh : lw
Set prevMainAxisSize = horizontal ? ow : oh
Set prevCrossAxisSize = horizontal ? oh : ow
if (mainAxisSize !== prevMainAxisSize) {
	// Change in axis size! We need to recalc layout fully.
	this.layout()
} else if(crossAxisSize !== prevCrossAxisSize) {
	this.alignCross()
	this.ow = lw
	this.oh = lh
}

AlignCross:
When the cross axis size is changed, repositions all layout lines on the cross axis (see align-content).
No dimensions are changed during this operation, so no re-layout is necessary.
Recalc flag '2' should be set for children though if the lw,lh changes.


PROBLEM: within bounds detection for flexbox containers:
When flexbox is within bounds, load all items in one go.

Find direction x:
positive or negative?
Find direction y:
positive or negative?
if flexbox xy with infinite w/h could be visible: enforce loading textures of all direct items that do not have mw or mh specified.
Otherwise just use mw or mh. In the meantime, use 0,0 instead of 2048, 2048 while layouting.

toggeling visiblity may be key in practice.

When to load texture?!
Absolute > part of update loop.
In case of flexbox, it's better to postpone until the next frame.
When flex container is (possibly) within view, all items should be loaded.